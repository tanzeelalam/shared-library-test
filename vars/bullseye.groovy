/**
 * Executes a Bullseye scan
 *
 * <h4>Sample usage:</h4>
 * <pre>
 * bullseye(
 *     sourceDir: "build_folder",
 *     buildCmd: "npm run build",
 *     filesToBackup: "*.cpp",
 *     testFileToRun: "tests\\unit_tests.exe",
 *     exclusionsFile: "exclusions.txt",
 *     covFile: env.WORKSPACE + "\\bullseye.cov",
 *     coverageType: 'Unit Tests',
 * )
 * </pre>
 * @param sourceDir [T:String] [OPTIONAL] Source code location. [DEFAULT:env.WORKSPACE]
 * @param buildCmd [T:String] A standard call to a build script or command.
 *                            e.g.: Ant, MSBuild, NPM, build.bat (etc)
 * @param filesToBackup [T:String] Comma separated list of files generated by the bullseye build which you want to keep.
 *                      These are required by the development team to execute bullseye. If not provided, there is no reason to perform
 *                      a bullseye build.
 * @param testFileToRun [T:String|List&lt;String&gt;] The file path or list of file paths to execute after the project has been built for getting coverage.
 *                      These are required to execute bullseye code coverage. This path should be relative to the root of the build path.
 * @param projName [T:String] [OPTIONAL] User specified projName for the build command. [DEFAULT:env.BUILD_PARAM_COMPONENT]
 * @param logfile [T:String] [OPTIONAL] User specified logfile for the build command
 * @param exclusionsFile [T:String] [OPTIONAL] The Path of the File which contains the regions to exclude in the Bullseye Coverage.
 *                       This path should be relative to the root of the repository/build path.
 * @param covFile [T:String] [OPTIONAL] Location & name of Bullseye cov file to generate.
 *                 [DEFAULT:env.WORKSPACE + "\\bullseye.cov"]
 * @param coverageType [T:String] [OPTIONAL] The Coverage type under which results will be posted to Radar.
 *                     When set, it changes the CoverageType under which CodeCoverage results are posted in Radar. It is recommended to set this value 
 *                     when doing more than one bullseye run in a single build. [DEFAULT:Bullseye]
 */
def call(Map arg) {
    try {
        generate(arg)
    } catch (Throwable e) {
        rethrow(e, 'Bullseye failed')
    }
}

private void generate(arg) {
    global()
    log.debug(arg)
    Boolean stashForTest = arg.stashForTest?.toBoolean() ? true : false
    String projName = arg.projName ?: env.BUILD_PARAM_COMPONENT
    String bullseyeHomeWindows = global.path.WIN_BULLSEYECOVERAGE_BIN_DIR
    if(!utils.isNullOrEmptyString(env.BULLSEYE_HOME)) {
        log.debug("Setting Bullseye Path from Environment Variable : ${env.BULLSEYE_HOME}")
        bullseyeHomeWindows = env.BULLSEYE_HOME + "\\bin"
    }
    String inputDir = arg.sourceDir
    String linuxPreCmd = "{ set +x; } 2>/dev/null; "
    String linuxPostCmd = "; { set -x; } 2>/dev/null"
    String bullseyeBinDir = isUnix() ? global.path.UNIX_BULLSEYE_BIN_DIR : bullseyeHomeWindows + "\\" 
    String separator = isUnix() ? "/" : "\\"
    String covFile = arg.covFile ?: env.WORKSPACE + separator + "bullseye.cov"
    String coverageType = arg.coverageType ?: "Bullseye"
    String bullseyeBackup = arg.projName ?: ""
    bullseyeBackup = bullseyeBackup + "_bullseyeBackup.zip"

    if (!arg.logfile) {
        arg.logfile = "bullseyeLogs.log"
    }

    // TODO : add support for MAC. Use node.isMac()
    
    
    try {
        arg.filesToBackup = arg.filesToBackup ?: covFile
        assert !utils.isNullOrEmptyString(arg.sourceDir): "ERROR: sourceDir parameter is required."
        assert !utils.isNullOrEmptyString(arg.buildCmd): "ERROR: buildCmd parameter is required."
        assert (arg.testFileToRun) : "ERROR: testFileToRun parameter is required."
        assert !utils.isNullOrEmptyString(arg.filesToBackup): "ERROR: filesToBackup parameter is required."
        assert (arg.filesToBackup): "ERROR : arg.filesToBackup missing , provide a list of files to backup"
        assert (arg.filesToBackup.size() > 0): "ERROR : arg.filesToBackup empty , provide a list of files to backup"

        String bullseyeStart        =   bullseyeBinDir + "cov01 --on --verbose" // Command to Enable Bullseye
        String bullseyeCmd          =   arg.buildCmd // Bulls Eye Build Command
        def testFilesArray          =   arg.testFileToRun instanceof List ? arg.testFileToRun : [arg.testFileToRun,]  // Convert it to a list if its a String
        String bullseyeEnd          =   bullseyeBinDir + "cov01 --off --verbose" // Command to Disable Bullseye
        String bullseyeSelect       =   bullseyeBinDir + 'covselect --verbose --file %COVFILE% --import ' + inputDir + separator + arg.exclusionsFile //Bulls eye Exclusions Command
        String deleteExclusions     =   bullseyeBinDir + 'covselect --deleteAll --verbose' // Command to delete any previous Bullseye exclusions

        log.debug("coverageType : " + coverageType)
        log.debug("buildCmd : " + arg.buildCmd)
        log.debug("sourceDir : " + inputDir)
        log.debug("covFile : " + covFile)
        log.debug("projName : " + projName)
        log.debug("logfile : " + arg.logfile)
        log.debug("filesToBackup : " + arg.filesToBackup)
        log.debug("bullseyeStart : " + bullseyeStart)
        log.debug("bullseyeCmd : " + bullseyeCmd)
        log.debug("TestFilesToRun : ${testFilesArray}")
        log.debug("bullseyeEnd : " + bullseyeEnd)
        log.debug("bullseyeSelect : " + bullseyeSelect)

        dir(arg.sourceDir) {
            def outputDir
            dir("reportOut") {
                outputDir = pwd()
            }
            int returnStatus = 0
            withEnv(["COVFILE=" + covFile, "OUTPUT=" + outputDir, "COVBUILDZONE=" + orbit.buildRecordId()]) {
                // Turn Bullseye Coverage on
                env.current_task = bullseyeStart
                if (isUnix()) {
                    log.debug("Running bullseyeStart : " + linuxPreCmd + bullseyeStart + linuxPostCmd)
                    returnStatus = sh(script: linuxPreCmd + bullseyeStart + linuxPostCmd, returnStatus: true)
                } else {
                    log.debug("Running bullseyeStart : " + bullseyeStart)
                    returnStatus = bat(returnStatus: true, script: bullseyeStart)
                }
                if (returnStatus != 0) {
                    throw new Exception(
                        "Enable Bullseye failed. Process exited with code $returnStatus"
                    )
                } else {
                    log.info('Enabled Bullseye')
                }
                // Delete any predefined Exclusions in the Node
                env.current_task = deleteExclusions
                if (isUnix()) {
                    log.debug("Delete Any previous Exclusions : " + linuxPreCmd + deleteExclusions + linuxPostCmd)
                    returnStatus = sh(script: linuxPreCmd + deleteExclusions + linuxPostCmd, returnStatus: true)
                } else {
                    log.debug("Delete Any previous Exclusions : " + deleteExclusions)
                    returnStatus = bat(returnStatus: true, script: deleteExclusions)
                }
                if (returnStatus != 0) {
                    throw new Exception(
                        "Delete previous Bullseye selections failed. Process exited with code $returnStatus"
                    )
                }
                
                // Build the Project
                log.info("Running Build Command : " + bullseyeCmd)
                env.current_task = bullseyeCmd
                if (isUnix()) {
                    returnStatus = sh(script: linuxPreCmd + bullseyeCmd + linuxPostCmd, returnStatus: true)
                } else {
                    returnStatus = bat(returnStatus: true, script: bullseyeCmd)
                }
                if (returnStatus != 0) {
                    throw new Exception(
                        "Bullseye compile for '$projName' failed. Process exited with code $returnStatus"
                    )
                } else {
                    log.info("Completed : " + bullseyeCmd)
                }
                
                // Run the Project
                testFilesArray.each { testFile ->
                    String bullseyeRun = arg.sourceDir + separator + testFile // Bullseye Run test Command
                    env.current_task = bullseyeRun
                    if (isUnix()) {
                        log.debug("Executing tests : " + linuxPreCmd + bullseyeRun + linuxPostCmd)
                        returnStatus = sh(script: linuxPreCmd + bullseyeRun + linuxPostCmd, returnStatus: true)
                    } else {
                        log.debug("Executing tests : " + bullseyeRun)
                        returnStatus = bat(returnStatus: true, script: bullseyeRun)
                    }
                    if (returnStatus != 0) {
                        throw new Exception(
                            "Bullseye Run for '$projName' failed. Process exited with code $returnStatus"
                        )
                    } else {
                        log.info("Completed : " + bullseyeRun)
                    }
                }

                // Import any exclusions if an exclusion file is provided
                if(!utils.isNullOrEmptyString(arg.exclusionsFile)) {
                    env.current_task = bullseyeSelect
                    if (isUnix()) {
                        log.debug("bullseyeSelect : " + linuxPreCmd + bullseyeSelect + linuxPostCmd)
                        returnStatus = sh(script: linuxPreCmd + bullseyeSelect + linuxPostCmd, returnStatus: true)
                    } else {
                        log.debug("bullseyeSelect : " + bullseyeSelect)
                        returnStatus = bat(returnStatus: true, script: bullseyeSelect)
                    }
                    if (returnStatus != 0) {
                        throw new Exception(
                            "Select Bullseye failed. Process exited with code $returnStatus"
                        )
                    } else {
                        log.info('Selecting: ' + covFile + ", Importing from: " + arg.exclusionsFile)
                    }
                }
            }
        }
        env.current_task = bullseyeEnd
        withEnv(["COVFILE=" + covFile, "COVBUILDZONE=" + orbit.buildRecordId()]) {
            if (isUnix()) {
                log.debug("Running endBullseye : " + linuxPreCmd + bullseyeEnd + linuxPostCmd)
                returnStatus = sh(script: linuxPreCmd + bullseyeEnd + linuxPostCmd, returnStatus: true)
            } else {
                log.debug("Running endBullseye : " + bullseyeEnd)
                returnStatus = bat(returnStatus: true, script: bullseyeEnd)
            }
            if (returnStatus != 0) {
                throw new Exception(
                    "Disable Bullseye failed. Process exited with code $returnStatus"
                )
            } else {
                log.info('Disabled Bullseye')
            }
        }
        
        if (fileExists(covFile)) {
            // Uploading CovFile to Artifactory
            artifacts.upload([files: covFile])
            // Uploading covFile to Radar
            uploadToRadar(covFile, coverageType)
        } else {
            throw new Exception(
                "Bullseye Cov file, " + covFile + " was not generated by the command: " + arg.buildCmd
            )
        }
        ziputils.createZip([
            fileName: bullseyeBackup,
            input   : arg.filesToBackup.toString()
        ])
        if (stashForTest) {
            stash includes: bullseyeBackup, name: projName + "_bullseye"
        }
        artifacts.upload([files: bullseyeBackup])
    } catch (Throwable e) {
        rethrow(e)
    } finally {
        if (fileExists(arg.logfile)) {
            artifacts.upload([files: arg.logfile])
            log.info("Bullseye logfile name: " + arg.logfile)
        } else {
            log.error("File " + arg.logfile + " was not generated by the command: " + arg.buildCmd)
        }
    }
}

private void process(outputDir, uploadedURL) {
    log.debug(outputDir)
    try {

        def inputXML = readFile(encoding: 'UTF-8', file: outputDir + '\\clover.xml')
        def coverage = new XmlSlurper().parseText(inputXML)
        def mapSize = coverage.project.package[0].file.size()
        coverage = null
        //JSON & XML Slurper objects can cause java.io.NotSerializableException if not unset before leaving scope.
        def jsonFile

        //env.BULLSEYE_REPORT_PER_FILE is currently unused, skip to else statement.
        if (env.BULLSEYE_REPORT_PER_FILE > 0) {
            //TODO: This var is a placeholder as radar cannot handle per file reporting yet. Come up with a more elegant method later.
            for (def i = 0; i < mapSize; i++) {
                coverage = new XmlSlurper().parseText(inputXML)
                def path = coverage.project.package[0].file[i]['@path'][0].text().toString()
                def coveredconditionals = coverage.project.package[0].file[i].metrics[0]['@coveredconditionals'][0].text().toInteger()
                def conditionals = coverage.project.package[0].file[i].metrics[0]['@conditionals'][0].text().toInteger()
                def coveredmethods = coverage.project.package[0].file[i].metrics[0]['@coveredmethods'][0].text().toInteger()
                def methods = coverage.project.package[0].file[i].metrics[0]['@methods'][0].text().toInteger()
                coverage = null
                //JSON & XML Slurper objects can cause java.io.NotSerializableException if not unset before leaving scope.

                //TODO: Turn into one large JSON post instead of so many small POSTs.
                /*
                upload([
                        filename            : path, //path.tokenize('/')[-1],
                        decisionCoverage 	: coveredconditionals,
                        uncoveredDecision   : conditionals - coveredconditionals,
                        functionCoverage    : coveredmethods,
                        uncoveredFunctions  : methods - coveredmethods
                ])
                */
                log.debug("filename: " + path.replace('\\', '\\\\'))
                log.debug("decisionCoverage: " + coveredconditionals)
                log.debug("uncoveredDecision: " + (conditionals - coveredconditionals))
                log.debug("functionCoverage: " + coveredmethods)
                log.debug("uncoveredFunctions: " + (methods - coveredmethods))
            }
        } else {
            coverage = new XmlSlurper().parseText(inputXML)
            def coveredconditionals = coverage.project.package[0].metrics[0]['@coveredconditionals'][0].text().toInteger()
            def conditionals = coverage.project.package[0].metrics[0]['@conditionals'][0].text().toInteger()
            def coveredmethods = coverage.project.package[0].metrics[0]['@coveredmethods'][0].text().toInteger()
            def methods = coverage.project.package[0].metrics[0]['@methods'][0].text().toInteger()
            coverage = null
            //JSON & XML Slurper objects can cause java.io.NotSerializableException if not unset before leaving scope.

            upload([
                    url               : uploadedURL,
                    decisionCoverage  : coveredconditionals,
                    uncoveredDecision : conditionals - coveredconditionals,
                    functionCoverage  : coveredmethods,
                    uncoveredFunctions: methods - coveredmethods
            ])
        }

    } catch (Throwable e) {
        rethrow(e)
    }
}

private void upload(arg) {
    request.post(
        url: global.radarUrl.CodeCoverageResults,
        error: 'Failed to upload Bullseye results to Radar.',
        token: 'orbit_radar_cred',
        json: [
            BuildRecordId: orbit.buildRecordId(),
            FunctionCoverage: arg.functionCoverage,
            UncoveredFunctions: arg.uncoveredFunctions,
            DecisionCoverage: arg.decisionCoverage,
            UncoveredDecision: arg.uncoveredDecision,
            CoverageType: "UT",
            CoverageTool: "Bullseye",
            CoverageToolVersion: 8,
            URL: arg.url,
        ],
    )
}


private String getBullseyeVersion() {
    global()
    String versionString = ""
    if (isUnix()) {
        versionString = utils.silentCmd(global.path.UNIX_BULLSEYE_BIN_DIR + '/covmgr --version')
    }
    else {
        def bullseyeHomeWin = global.path.WIN_BULLSEYECOVERAGE_BIN_DIR
        if(env.BULLSEYE_HOME) {
            bullseyeHomeWin = env.BULLSEYE_HOME + "\\bin"
        }
        versionString = utils.silentCmd(bullseyeHomeWin + '\\covmgr --version') 
    }
    String version = (versionString =~ /([\d.]+)/)[0][1]
    log.debug("Bullseye Coverage Version found : " + version)
    return version
}


/**
 * Upload <code>bullseye.cov</code> results to Radar.
 *
 * <pre>
 * bullseye.uploadToRadar(env.WORKSPACE + "\\bullseye.cov")
 * </pre>
 * @param covFile [T:String] The absolute path to the <code>bullseye.cov</code> file.
 * @param coverageType [T:String] [OPTIONAL] The coverage type. [DEFAULT:"Bullseye"]
 */
public void uploadToRadar(String covFile, String coverageType="Bullseye"){
    global()
    assert !utils.isNullOrEmptyString(covFile): "ERROR: covFile parameter is required."
    String testReportFile = ''
    String resultFilename = 'bullseyecoverage-result.xml'
    String bullseyeHomeWin = global.path.WIN_BULLSEYECOVERAGE_BIN_DIR
    String bullseyeHomeUnix = global.path.UNIX_BULLSEYE_BIN_DIR
    testReportFile = env.WORKSPACE + '/.orbit/' + resultFilename
    if(isUnix()){
        sh global.path.UNIX_BULLSEYE_BIN_DIR + '/covxml -f ' + covFile + ' -o ' + testReportFile
    }
    else {
        if(env.BULLSEYE_HOME) {
            bullseyeHomeWin = env.BULLSEYE_HOME + "\\bin"
        }
        bat bullseyeHomeWin + '\\covxml -f ' + covFile + ' -o ' + testReportFile
    }
    if(postResultsToRadar(testReportFile, coverageType)) {
        log.info("Posted BullsEye XML ${testReportFile} to Radar.")
    } else {
        log.warn("Failed to Post BullsEye XML ${testReportFile} to Radar.")
    }
}


private boolean postResultsToRadar(filePath, String coverageType="Bullseye")
{
    File resultsFilePath = new File(filePath)
    try
    {
        dir(resultsFilePath.getParent().toString())
            {
                def xml = readFile filePath
                def tests = new XmlParser().parseText(xml)

                int percentfunctionsCovered = (((tests.attribute("fn_cov") as float)/(tests.attribute("fn_total") as float))*100).round()
                int percentdecisionsCovered = (((tests.attribute("cd_cov") as float)/(tests.attribute("cd_total") as float))*100).round()

                radar.setBullseyeResults(percentfunctionsCovered,percentdecisionsCovered, getBullseyeVersion(), coverageType)
                return true
            }
    }
    catch (Exception err)
    {
        log.warn("Error with Bullseye Result upload: " + err)
        return false
    }
}
